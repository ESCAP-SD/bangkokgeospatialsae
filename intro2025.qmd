---
title: "Geospatial/SAE workshop"
subtitle: "Introduction - SAE and R"
author: "Josh Merfeld"
date: "November 2025"
date-format: "MMMM YYYY"

format: 
  revealjs:
    self-contained: true
    slide-number: false
    progress: false
    theme: [serif, custom2025.scss]
    width: 1500
    height: 1500*(9/16)
    code-copy: true
    code-fold: show
    code-overflow: wrap
    highlight-style: github
execute:
  echo: true
  warnings: false
---

```{r setup, include=FALSE}

library(tidyverse)
library(nycflights13)
library(kableExtra)
library(cowplot)
library(sf)
library(tidyterra)
library(terra)
library(haven)

# read in the data
data <- read_csv("introdata/data.csv")
```



# Introduction


## Introduction


- Course website: [https://github.com/ESCAP-SD/bangkokgeospatialsae](https://github.com/ESCAP-SD/bangkokgeospatialsae) 
  - I strongly recommend you have this website open during the workshop

- I will often use data from the website
  - Today is the "intro" section
  
  

## General outline

- Today: starting easy!
  - Hopes for the workshop? Goals? (done!)
  
. . .


- Review of everyone's experiences with R

. . .

- Making sure we are all on the same page





## Why small area estimation?


```{r}
#| echo: false
#| include: true
#| fig-align: center

admin2 <- read_sf("introdata/mw2.shp")
admin3 <- read_sf("introdata/mw3.shp")
admin3 <- st_transform(admin3, crs = st_crs(admin2))
survey <- read_dta("introdata/householdgeovariables_ihs5.dta")
survey$DIST_CODE <- substr(survey$case_id, 1, 3)
survey$TA_CODE <- substr(survey$case_id, 1, 5)

temp <- survey |>
  group_by(DIST_CODE) |>
  summarise(n = n())
admin2 <- admin2 |>
  left_join(temp, by = "DIST_CODE")

temp <- survey |>
  group_by(TA_CODE) |>
  summarise(n = n())
admin3 <- admin3 |>
  left_join(temp, by = "TA_CODE")

admin3$n[is.na(admin3$n)] <- 0

g1 <- ggplot() + 
  geom_sf(data = admin2, aes(fill = n), color = NA, lwd = 0.001) +
  scale_fill_distiller("Observations", palette = "Spectral", limits = c(1, max(admin2$n))) +
  theme_bw() +
  labs(subtitle = "District (admin2)") +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(legend.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC"))
g2 <- ggplot() + 
  geom_sf(data = admin3, aes(fill = n), color = NA, lwd = 0.001) +
  scale_fill_distiller("Observations", palette = "Spectral", limits = c(1, max(admin2$n))) +
  theme_bw() +
  labs(subtitle = "TA (admin3)") +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(legend.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC"))

# extract the legend from one of the plots
legend <- ggpubr::get_legend(g1 +
  # horizontal legend
  guides(color = guide_legend(nrow = 1)) +
  theme(legend.position = "bottom"))
grid <- plot_grid(g1 + theme(legend.position = "none"), g2 + theme(legend.position = "none"), ncol = 2)
plot_grid(grid, legend, ncol = 1, rel_heights = c(1, 0.1)) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(legend.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC"))
```



## Geospatial data is widely available!

-   [One estimate](https://www.ibm.com/topics/geospatial-data) says that 100 TB of only weather data are generated every single day
    -   This means there is a lot of data to work with!
    -   Note that this is also problematic, since it can be difficult to work with such large datasets

. . .

-   Geospatial data is used in a variety of fields
    -   Agriculture
    -   Urban planning
    -   Environmental science
    -   Public health
    -   Transportation
    -   And many more!

## The amount of geospatial data is useful for SAE

-   Geospatial data can be highly predictive of e.g. poverty
    -   Urbanity
    -   Land class/cover
    -   Vegetation indices
    -   Population counts
    -   etc. etc.

. . .

-   More importantly: it's available everywhere!

## Think of what you need for SAE

-   You need a sample, e.g. a household survey
    -   This will only cover some of the country

. . .

-   You need auxiliary data that is:
    -   Predictive of the outcome you care about
    -   Available throughout the entire country

. . .

-   Some countries use administrative data
    -   But, importantly, it's often not available or is of low quality!
    

## A quick example

-   Let's take a look at Malawi

-   Why Malawi?

    -   I have survey data you can use ðŸ˜ƒ
    - Only going to use part of Malawi for this example (size of data)

-   Consider the 2019/2020 Integrated Household Survey (IHS5)

    -   Was used for the Malawi Poverty Report 2020
    -   Can say things about poverty at the district level
    - If you want to split by urban/rural, only at the region level

## A quick example

![](introassets/malawipov.png){fig-align="center"}


## Malawi admin areas - Northern region only

::: columns
::: {.column width="70%"}
```{r}
#| echo: false
#| include: true
#| fig-align: center

admin2 <- read_sf("introdata/mw2.shp")
admin3 <- read_sf("introdata/mw3.shp")
admin4 <- read_sf("introdata/mw4.shp")

g1 <- ggplot() + 
  geom_sf(data = admin2, fill = "white", color = "black") +
  theme_bw() +
  labs(subtitle = "District (admin2)") +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(legend.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC"))
g2 <- ggplot() + 
  geom_sf(data = admin3, fill = "white", color = "black") +
  theme_bw() +
  labs(subtitle = "TA (admin3)") +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(legend.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC"))
g3 <- ggplot() + 
  geom_sf(data = admin4, fill = "white", color = "black") +
  theme_bw() +
  labs(subtitle = "EA (admin4)") +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(legend.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC"))

plot_grid(g1, g2, g3, ncol = 3) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(plot.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC")) +
  theme(legend.background = element_rect(fill = "#D7D1CC", color = "#D7D1CC"))
```
:::

::: {.column width="30%"}
-   Survey only lets us say things about the districts!
-   What if we want to say something about traditional authorities (TAs)?
-   Individual TAs might not have enough observations
-   We could use SAE! But what auxiliary data?
:::
:::




## Census data?

- Traditional SAE uses census data

. . .

- The problem:
  - Some countries do not have census data
  - Others have census data that is old
    (how well old census data works is an area of active research!)




## But geospatial data can be used!


  - Geospatial data available more or less everywhere on earth

. . .
  
  - Geospatial data is updated frequently!
    - Some imagery datasets are updated daily
    - Most updated at least annually








# R and RStudio


## R and RStudio


- We need to have R and RStudio installed for what's next
  - Another code editor is also acceptable: VS Code, for example
  










## Goal for the session




- The goal for today is to give you a brief introduction to R and R Markdown


- We will be using two small datasets to get you familiar with the program


- A note: if you are completely new to R, the first few weeks will be a slog
  - It will get better, I promise


- Much of the material covered today comes from two (free!) sources:
  - [R for Data Science](https://r4ds.hadley.nz/)
  - [R Markdown: The Definitive Guide](https://bookdown.org/yihui/rmarkdown/)





## What are R and RStudio?


- R is a commonly used statistical program (and language)
  - It is free and open source, which means you can use this after graduation, without paying for it
  - R is CaSe SeNsItIvE

- To work with R, we want to use an accompaniment called RStudio
  - RStudio is what is referred to as an integrated development environment (IDE)
  - It is not the only option (VS Code, for example), but it is the most common
  - It makes working with R much easier

- Whenever you start R, you want to start RStudio
  - RStudio will start R for you





## Some important considerations


- One of our goals is to make **reproducible** research
  - This means that we want to be able to share our code and have others be able to replicate our results
  - To do this, we will use "scripts" that contain our code

. . .

- A script should be self contained
  - This means that it should contain all of the code necessary to run the analysis
  - A well-written script should allow me to do everything without any additional information
  - Note that more complicated projects can have many scripts! For this class: one script per assignment

. . .

- We will learn about using R Markdown to create documents
  - R Markdown is a way to combine text and code
  - This allows us to create documents that are reproducible





## The RStudio interface

```{r rstudio1, echo = FALSE, message = FALSE, warning = FALSE, out.width = "90%", fig.align = "center"}

knitr::include_graphics(
                        path = "introassets/rstudio1.png",
                        auto_pdf = TRUE
                        )

```




## The RStudio interface

```{r rstudio2, echo = FALSE, message = FALSE, warning = FALSE, out.width = "90%", fig.align = "center"}

knitr::include_graphics(
                        path = "introassets/rstudio2.png",
                        auto_pdf = TRUE
                        )

```




## The RStudio interface

```{r rstudio3, echo = FALSE, message = FALSE, warning = FALSE, out.width = "90%", fig.align = "center"}

knitr::include_graphics(
                        path = "introassets/rstudio3.png",
                        auto_pdf = TRUE
                        )

```




## The RStudio interface

```{r rstudio4, echo = FALSE, message = FALSE, warning = FALSE, out.width = "90%", fig.align = "center"}

knitr::include_graphics(
                        path = "introassets/rstudio4.png",
                        auto_pdf = TRUE
                        )

```




## But we're missing something... what is it?
\pause

```{r rstudio5, echo = FALSE, message = FALSE, warning = FALSE, out.width = "90%", fig.align = "center"}

knitr::include_graphics(
                        path = "introassets/rstudio5.png",
                        auto_pdf = TRUE
                        )

```




## The script


```{r rstudio6, echo = FALSE, message = FALSE, warning = FALSE, out.width = "90%", fig.align = "center"}

knitr::include_graphics(
                        path = "introassets/rstudio6.png",
                        auto_pdf = TRUE
                        )

```




## Some notes

- You can add comments to your script using a hashtag (#)
  - At the top of ALL my scripts, I have a comment that says what the script does.
  - At the top of your script, write a comment. It should say "# Week 1 - Introduction to R"
  - I put LOTS of comments in my scripts. This is good practice.
  
```{r}
#| echo: true
# cleaning the gps data and creating some maps
# to run this, just set your working directory to the folder this script is located in
# Author: Josh Merfeld
# Initial date: September 5th, 2024
```

```{r}
#| echo: true
# lasso --------------------------------------------
# we have ~60 features. This isn't that many, actually. We didn't create a lot of different possible combinations of the predictors.
# We also don't have any fixed effects. This is just to fix ideas. Nonetheless, let's try lasso!
# we use the glmnet package to implement lasso. It also allows ridge, but we want to make sure to use lasso.
# how do we do this? we want to allocate grid cells across different "folds".
```






## Some notes

- You can run a line of code by clicking the "Run" button
  - There are also shortcuts. On Mac it is command + enter. On windows it is control + enter. You can change these if you want.

- You can run multiple lines of code by highlighting them and clicking the "Run" button (or the shortcut)

- We will practice these later





# R Basics

## Object types

- R has a few different types of objects
  - The most common are vectors, matrices, and data frames
    - A "tibble" is a type of data frame used by the `tidyverse` package (more below)
  - We will use data frames almost exclusively since we are working with datasets, but vectors are common, too
- You can create a vector using the `c()` function:
  - Note how we create a new object using the assignment operator, `<-`. You can also use `=`.^[They are technically different. But you can generally treat them as the same.]


```{r}
#| echo: true
vec <- c(1, 2, 3, 4)
vec
```



## Object types

- You can check what type of object something is by using the `class()` function
  - For example, if I want to check what type of object vec is, I would write `class(vec)`
  - Note that the output is "numeric"
  - This is because vec is a vector of numbers
```{r}
#| echo: true
vec <- c(1, 2, 3, 4)
class(vec)
```
- If I want to check whether it is a vector, I can write `is.vector(vec)`
  - Note that the output is TRUE

```{r}
#| echo: true
is.vector(vec)
```







## First things first: the working directory

- The working directory is the folder that R is currently working in
  - This is where R will look for files
  - This is where R will save files
  - This is where R will create files

- You can always write out an entire file path, but this is tedious
  - More importantly, it makes your code less reproducible since the path is specific to YOUR computer

- One nice thing about R is that the working directory will automatically be where you open the script from
  - Let's try this. Save your script to a folder on your computer, then open the script from that folder.





## First things first: the working directory

The working directory should be where you opened the file from. Check it like this:

```{r wd, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}

getwd()

```





## R packages


- R is a language that is built on packages
  - Packages are collections of functions that do specific things
  - R comes with a set of "base" packages that are installed automatically

- We are going to use one package consistently, called the "tidyverse"
  - This consists of a set of packages that are designed to work together, with data cleaning in mind






## R packages


The one exception to always using a script? I install packages in the CONSOLE. You can install packages like this:

```{r tidyinstall, echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE, size = "tiny"}

install.packages("tidyverse")

```

- Note you MUST use quotes around the package name





## Loading R packages in your script


We need to load any R packages we want to use at the very top of the script. You should have a comment on line one, so on line two write:

```{r tidyverse, echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE, size = "tiny"}

library(tidyverse)

```

This will load the tidyverse package.

- Note you do NOT need to use quotes around the package name






## Loading data


- Go to the class website and download the data for today.
  - Put it in your WORKING DIRECTORY (where the script is)

- We will use the `read_csv()` function to load the data
  - This function is part of the tidyverse package
  - It will create a data frame
  - We need to NAME the object (data frame). As before, note the assignment operator (`<-`). You can actually use `=` though.

```{r data, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}

library(tidyverse)

# read in the data
data <- read_csv("introdata/data.csv")

```





## Objects in memory

The data frame should show up in the upper right hand corner of RStudio.

```{r rstudio7, echo = FALSE, message = FALSE, warning = FALSE, out.width = "90%", fig.align = "center"}

knitr::include_graphics(
                        path = "introassets/rstudio7.png",
                        auto_pdf = TRUE
                        )

```




## Objects in memory

Click on the arrow and it will show more information.

```{r rstudio8, echo = FALSE, message = FALSE, warning = FALSE, out.width = "90%", fig.align = "center"}

knitr::include_graphics(
                        path = "introassets/rstudio8.png",
                        auto_pdf = TRUE
                        )

```




## Objects in memory


- The data frame is a matrix
  - Each row is an observation and each column is a variables
  - Think of what this would look like if you opened it in Excel or Stata. It's the same.

- We can also see the names of the columns like this:

```{r}
colnames(data)
```

- This is the kind of thing I might do in the console since it's not really required for the script.




## Objects in memory


- Here's another handy quick-look functions

```{r}

glimpse(data)

```




## Objects in memory


- And one more ("structure")

```{r}

str(data)

```








## Calling variables in R

- Some of you might be used to Stata
- One big difference between the two is that Stata generally only has one data frame in memory at a time
  - This means that you can call a variable *without referencing the data frame*
- In R, if you want to look at a variable, you have to tell R which data frame it is in
  - This is done with the `$` operator
  - For example, if I want to look at the variable "age" in the data frame "data", I would write `data$age`
  - Let's look at summary statistics for age:

```{r}

summary(data$age)

```





## Summary statistics for the entire data frame

- You can also use summary on the data frame instead of a single column
  - It helps to think of a data frame as rows and columns. For variables, you want to call specific columns.
- Look at the difference here:

```{r}

summary(data)

```





## Calling rows/columns of a data frame (matrix)

- Think about how we refer to rows and columns in a matrix.
  - We use the row and column number, in that order.
  - For example, if I want the first row and second column of a matrix $X$, mathematically I could write $X_{1,2}$
- We do *the same thing in R*
- If I want the first row and second column of the data frame "data", I would write `data[1,2]`
  - Note that we use square brackets instead of parentheses
  - Note that we use a comma to separate the row and column

```{r}

data[1,2]

```




## Calling columns of a data frame (matrix)

- We can call entire columns of a data frame by leaving the row blank
  - For example, if I want the second column of the data frame "data", I would write `data[,2]`
  - Note that the second column is the ability variable

```{r}
#| class-output: hscroll
colnames(data)
```

```{r}
data[,2]
```




## Missing variables R

- Missing variables are denoted by NA
  - This is different from Stata, which uses a period (.)
- Note that this is only how the PROGRAM stores missing variables. Sometimes the data itself has different missing values.
- For example, take a look at the first ten rows of the data frame (also note how I call the first ten rows and leave out the first column!):

```{r}
data[1:10,-1]
```




## Variable types

- R also has a few different types of variables
  - The most common are numeric, character, and logical
- Look at the previous code again:

```{r missing2, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
data[1:10,-1]
```




## Variable types

- `dbl` is short for double, which is a numeric variable (the "type" of numeric variable is about how much memory is needed to store it)
- `chr` is short for character, which is a string of characters (text)
  - Surprisingly, in our previous example, `educyears` was a character string even though it seemed to be a number
  - Let's look at the possible values of `educyears` using the unique() function, which outputs a vector:

```{r uniqueeducyears, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
unique(data$educyears)
```




## Variable types

- Interesting! It seems that there is a "Not Mentioned" value.
  - What if we want to replace those with missing, instead?
- Let's talk through the following code
  - First note how it refers to a specific column and then a specific row
  - Also note how it uses two equal signs (`==`) to check whether the value is "Not Mentioned"
    - This is similar to Stata!

```{r replace, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
# replace "Not Mentioned" with NA
data$educyears[data$educyears=="Not Mentioned"] <- NA  
# check that it worked by looking at the unique values
unique(data$educyears)              
# turn into numeric
data$educyears <- as.numeric(data$educyears)
class(data$educyears)
```






## Pipes

- One of the most useful things in R is the pipe operator (`|>`)
  - This is part of the tidyverse package
  - It allows you to chain commands together
  - It makes your code much easier to read
  - It makes your code much easier to write
  - It makes your code much easier to debug
  - It makes your code much easier to share
  - It makes your code much easier to reproduce

- It's easy to use but it will take some time for you to get used to the names of the functions we can use with it
  - This also goes for other tasks in R, not just with the pipe operator






## Pipes example
Here is an example of how we can use pipes with the `mutate()` function in tidyverse

- We are also going to use `ifelse()` to make this work

```{r replacemutate, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
data <- data |>
          mutate(educyears = ifelse(educyears == "Not Mentioned", NA, educyears), # if educyears=="Not Mentioned", replace
                educyears = as.numeric(educyears))    # replace educyears as numeric (instead of character)
summary(data$educyears)
```
\pause
Note that we could wrap as.numeric() around the ifelse() command to do it on one line!

```{r replacemutate2, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears))) # wrapped into one line
summary(data$educyears)
```







## Missings and functions in R
In Stata, by default, functions ignore missing values

- R does not do this by default. Look at this:

```{r missingsNA, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears))) # wrapped into one line
mean(data$educyears)
```

If there are any missing values, the function will evalute to missing!

- But we can also do this:

```{r missingsNA2, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears))) # wrapped into one line
mean(data$educyears, na.rm = TRUE) # BE CAREFUL WITH THIS! Make sure it is indeed what you want to do.
```






## Functions and storing values
The mean() function in the previous slide outputs a single value
- That means we could store that value as an object:

```{r storingvalues, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears))) # wrapped into one line
meaneduc <- mean(data$educyears, na.rm = TRUE)
sdeduc <- sd(data$educyears, na.rm = TRUE)
meaneduc
sdeduc
```

How is this helpful? We can use these values later in our script!






## Functions and mutate()
We can combine the mean() and sd() functions within mutate to create a new, standardized variable:

```{r mutate_std, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"} 
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears)), # wrapped into one line
                 educyears_std = (educyears - mean(educyears))/sd(educyears))
summary(data$educyears_std)
```

Oh no! what happened?






## Functions and mutate()
We can combine the `mean()` and `sd()` functions within mutate to create a new, standardized variable:

```{r mutate_std2, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"} 
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears)), # wrapped into one line
                 educyears_std = (educyears - mean(educyears, na.rm = T))/sd(educyears, na.rm = T))
summary(data$educyears_std)
```

Note that we can shorten TRUE to T (or FALSE to F).






## Visualizations with ggplot2
- ggplot2 is a flexible way to create visualizations in R
- The basic idea is that you create a plot object and then add layers to it
- Let's create a histogram of educyears






## Visualizations with ggplot2
```{r ggplot, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears)))
# we call ggplot() and NOT ggplot2()
ggplot() +   # note how we use + here, NOT the pipe operator
  geom_histogram(data = data, aes(x = educyears)) # the histogram with geom_histogram
# data = data tells R to use the data frame "data", and the aes() is the aesthetic
# only an x value here since a histogram uses just a SINGLE value
```






## Visualizations with ggplot2
```{r ggplot2, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears)))
# we can save the plot as an object
g1 <- ggplot() +
        geom_histogram(data = data, aes(x = educyears))
g1
```






## Visualizations with ggplot2
```{r ggplot3, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears)))
# lots of ways to change the plot
g1 <- ggplot() +
        geom_histogram(data = data, aes(x = educyears)) +
        labs(
          title = "Histogram of educyears",
          x = "Years of education",
          y = "Count"
        )
g1
```






## One more example
```{r ggplot4, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
data <- data |>
          mutate(educyears = as.numeric(ifelse(educyears == "Not Mentioned", NA, educyears)))
g1 <- ggplot() +
        geom_histogram(data = data, aes(x = educyears)) +
        labs(
          title = "Histogram of educyears",
          x = "Years of education",
          y = "Count") +
        theme_bw()
g1
```






## Let's try this with a NEW dataset
First install a new package that has a dataset we will use (you can do this in the console):

```{r install, echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
install.packages("nycflights13")
```

Now let's see:

```{r flights, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
library(nycflights13)
glimpse(flights)
```






## Dates with lubridate
There's a nice package called lubridate that makes working with dates much easier.

```{r lubridate1, echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
library(lubridate)
# create a date variable
flights$date <- as_date(paste0(flights$year, "-", flights$month, "-", flights$day))
head(flights$date)
```







## Dates with lubridate
Departure time/arrival time is in the format HHMM (e.g., 1530 is 3:30pm). We can add this to the date

```{r lubridate2, echo = TRUE, message = TRUE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
flights$dep_time_new <- hm(paste0(flights$dep_time %/% 100, ":", flights$dep_time %% 100))
head(flights$dep_time_new, n = 20)
```







## One more example
Lubridate also lets us work with "periods"

```{r lubridate4, echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "45%", fig.align = "center"}
flights$dep_delay_new <- as.period(flights$dep_delay, unit = "minute")
# NOTE: You have to be very careful with taking means/medians, etc.
head(flights$dep_delay_new)
```













## Let's look at some new tidyverse functions

Let's get the average departure delay by NYC airport:

```{r flights2, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
# Remember I said be careful with means of periods/durations! Using the original value here.
flights |> 
    group_by(origin) |> # this groups ROWS based on their origin value
    summarize(avg_dep_delay = mean(dep_delay, na.rm = T)) # this summarizes the data, creating means absed on the grouping!
```

Note that this does not create a single value. Instead it creates a tibble (a data frame) summarizing the data by our grouping variable.







## Let's look at some new tidyverse functions

What if we want to save that tibble instead?

```{r flights3, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny"}
summat <- flights |> 
            group_by(origin) |> # this groups ROWS based on their origin value
            summarize(avg_dep_delay = mean(dep_delay, na.rm = T)) # this summarizes the data, creating means based on groups!
summat # print the 3x2 matrix in the console
```

I could then output this to a table if I wanted to (using Markdown, more on this later):
```{r flights4, echo = FALSE, message = FALSE, warning = FALSE, size = "tiny"}
summat <- flights |> 
            group_by(origin) |> # this groups ROWS based on their origin value
            summarize(avg_dep_delay = mean(dep_delay, na.rm = T)) # this summarizes the data, creating means based on groups!
kable(summat,
      align = "c", linesep = "") |>
      kable_classic_2()
```






## Let's look at a new plot
How does departure delay vary by time of day?

```{r flights5, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "55%", fig.align = "center"}
ggplot() + 
  geom_smooth(data = flights, aes(x = sched_dep_time, y = dep_delay))
```






## Let's look at a new plot
We can color code by origin, too!

```{r flights6, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "55%", fig.align = "center"}
ggplot() + 
  geom_smooth(data = flights, aes(x = sched_dep_time, y = dep_delay, color = origin))
```






## Make it prettier
```{r flights7, echo = TRUE, message = FALSE, warning = FALSE, size = "tiny", out.width = "55%", fig.align = "center"}
ggplot() + 
  geom_smooth(data = flights, aes(x = sched_dep_time, y = dep_delay, color = origin), se = FALSE) +
  labs(
    x = "Scheduled departure time",
    y = "Departure delay (minutes)") +
  theme_bw() + guides(color = guide_legend(title = "Departure airport"))
```







